 # MediGraphRAG

------
![cover](data/cover.png)

MediGraphRAG 项目旨在构建一个医疗知识图谱并基于此实现 RAG（Retrieval-Augmented Generation）方法，提升医学领域的信息管理与应用效率。项目通过知识点抽取、关系提取和知识融合，解决大模型在生成过程中可能出现的幻觉问题，确保生成内容的准确性和可靠性。最终目标是为医学教育和实践提供一个动态、准确的知识支持系统。

<div align='center'>
     <p>
        <a href='https://github.com/Lin-A1/MediGraphRAG'><img src='https://img.shields.io/badge/Project-Page-Green'></a>
        <img src='https://img.shields.io/github/stars/Lin-A1/MediGraphRAG?color=green&style=social' />
    </p>
     <p>
        <img src="https://img.shields.io/badge/python->=3.9.11-blue">
    </p>
</div>


## 数据来源

- `医学考试试题` 
- `医疗书籍`：https://github.com/scienceasdf/medical-books

## 知识图谱构建

- **[dataProcess.ipynb](dataProcess/dataProcess.ipynb)**

### 知识图谱构建

#### 1. 知识点抽取

- **[dataclean.py](dataProcess/dataclean.py)**

通过`qwen2.5:14b`从医学试题中抽取考题知识点，我们需要设置`promat`暗示模型需要进行知识的提取，而不是进行该题目的解题

`folder_path`的地址需要换成你的医疗试题数据集的地址，同时注意你的文档的清洗方式需要修改

从每一到试题中提取一个知识点，将其转换为`dict`格式，以便后续转为`json`,值得注意的是由于模型处理速度偏慢，且由于本地数据清洗可能存在内存溢出，模型宕机等情况，在这里我选择进行多次`IO操作`，牺牲时间以保证安全性的策略，在每次读取后立即进行数据的存储

清洗后的数据存储在[knowledge.json](data/knowledge/knowledge.json)中

<details>
<summary> knowledge.json </summary>
    
 ```text
 [
    {
        "knowledge": "急性造血停滞的特点包括突然出现的全血细胞减少、网织红细胞可降至零以及骨髓中可见巨大原红细胞。此病通常在无血液病的患者中发生，且其病程常呈自限性，在适当的支持治疗下可以自然恢复。因此选项A（均发生于无血液病的患者）不符合急性造血停滞的特点。"
    },
    {
        "knowledge": "老年人行走时不慎滑倒后出现右髋部疼痛、局部压痛及下肢短缩和外旋畸形，提示可能发生髋部损伤。根据症状描述，最可能的诊断是股骨转子间骨折。此部位骨折的特点包括短缩外旋畸形，且患者的年龄和跌倒方式增加了此类骨折的可能性。其他选项如髋关节脱位、髋臼骨折等虽然也可能导致类似的局部表现，但结合患者的具体体征，B项更符合临床实际情况。"
    },
    {
        "knowledge": "梗阻性黄疸的B超诊断最直接证据是肝内胆管普遍扩张以及胆总管直径增大。选项A中的描述‘肝内胆管普遍扩张，胆总管直径1.5cm’符合这一特征。因此，A是最直接的支持梗阻性黄疸诊断的结果。"
    }
  ]
 ```
</details>
   
#### 2. 关系抽取

- **[graphbuild.py](dataProcess/graphbuild.py)**

在前面我们提取知识点的基础上从知识点中提取数据，同样的我们采用`qwen2.5:14b`进行演本的提取，大致流程与前面知识点抽取的一致，但是需要注意的是为我们需要在`promat`中暗示好我们所需要的实体，与关系类别，否则他将可能抽取各种奇怪的实体与关系，这会让我们在后期进行知识融合的过程十分不利

<details>
<summary> 实体关系 </summary>

```text
- 实体字段
疾病（Disease）：疾病名称、疾病编码（如ICD-10）、描述、分类（如慢性病、传染病等）。
药物（Drug）：药物名称、剂量、适应症、禁忌、常见副作用。
症状（Symptom）：症状名称、描述、严重程度、出现频率。
治疗方法（Treatment）：治疗方案、方法（如手术、药物治疗）、疗效、适应症。
检查项目（Test）：检查名称、目的、结果范围、相关疾病。

- 关系字段
疾病与症状：哪些症状与哪些疾病相关联（例如，咳嗽与肺炎）。
疾病与药物：哪些药物用于治疗特定疾病（例如，阿莫西林用于治疗细菌感染）。
症状与检查项目：某些症状需要进行哪些检查（例如，咳嗽需要进行胸部X光）。
药物与副作用：药物可能引起的副作用（例如，阿司匹林可能导致胃肠不适）。

关系应当包括但不限于以下：["导致症状", "伴随症状", "治疗方法", "疗效", "风险因素", "保护因素", "检查方法", "检查指标", "高发人群", "易感人群", "药物治疗", "药物副作用", "病理表现", "生物标志物", "发生率", "预后因素", "病因", "传播途径", "预防措施", "生活方式影响", "相关疾病", "诊断标准", "自然病程", "临床表现", "并发症", "危险信号", "遗传因素", "环境因素", "生活方式干预", "治疗费用", "治疗反应", "康复措施", "心理影响", "社会影响"]

```

</details>

由于我们任务处理的字段过多，我们实行两步走的策略，将知识中的实体抽取后，再让模型从中寻觅关系
 
初步的知识图谱数据存储在[graph.json](data/knowledge/graph.json)中

<details>
<summary> 图谱存储格式 </summary>
    
```text
{
  "knowledge": "胰岛素是调节血糖水平的重要激素，胰腺是其主要分泌腺体。",
  "entities": [
    {
      "entity": "胰岛素",
      "type": "激素",
      "description": "调节血糖水平的激素"
    },
    {
      "entity": "血糖水平",
      "type": "生理指标",
      "description": "血液中的葡萄糖含量"
    },
    {
      "entity": "胰腺",
      "type": "器官",
      "description": "分泌胰岛素的腺体"
    }
  ],
  "relation": [
    {
      "entity1": "胰岛素",
      "relation": "调节",
      "entity2": "血糖水平"
    },
    {
      "entity1": "胰岛素",
      "relation": "主要分泌腺体",
      "entity2": "胰腺"
    }
  ]
}

```
    
</details>
    
比较遗憾的是由于大模型幻觉的原因，大模型出现了私自篡改我们字段的情况，比如最终生成的数据中没有`knowledge`,实体间他们使用了别的变量名等，目前这种情况可以通过[graphcheck.py](dataProcess/graphcheck.py)进行定位，我们将在进行知识融合前给出修复的脚本

大模型有比较致命的弱点是他在知识图谱抽取这方面，运行效率并不高，这一步可以通过传统NLP进行关系的抽取

#### 3. 知识融合

我们还有一部分数据的实体关系没有处理好，我们的A6000加班中......